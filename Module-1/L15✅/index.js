const generateArray = (length, max) => (
    [...new Array(length)]
      .map(() => Math.round(Math.random() * max))
  );

  
function heapify(arr, n, i) {
    let largest = i; // Наибольший элемент -- корень
    const left = 2 * i + 1;
    const right = 2 * i + 2;
    const parent = Math.floor((i - 1) /2);

    // Если левый дочерний элемент больше корня
    if (left < n && arr[left] > arr[largest] ) {
        largest = left;
    }

    // Если правый дочерний элемент больше, чем наибольший элемент на данный момент
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // Если наибольший элемент не корень
    // Меняем местами
    if (largest != i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];

        // рекурсирно преобразуем в поддерево 
        heapify(arr, n, largest)
    }
}

function heapSort(arr) {
    let n = arr.length;

    // Цикл для построения кучи
    // Мы начинаем с узла, который находится на позиции Math.floor(n / 2) - 1. Это последний узел, который имеет потомков. Узлы после этого индекса будут листовыми узлами (узлами без потомков).
    // В куче, представленной массивом, для узла с индексом i его левый дочерний элемент находится на позиции 2 * i + 1, а правый дочерний элемент — на позиции 2 * i + 2.
    // Мы итерируем в обратном порядке от последнего узла, имеющего потомков, к корню (индекс 0).
    // Это делается для того, чтобы сначала гарантировать, что поддеревья на нижних уровнях являются кучами, прежде чем корректировать узлы на более высоких уровнях.
    // Почему начинаем с Math.floor(n / 2) - 1?
    // Для дерева, представленного массивом, индексы узлов, у которых есть потомки, находятся в диапазоне от 0 до Math.floor(n / 2) - 1.
    // Узлы с индексами от Math.floor(n / 2) до n - 1 являются листовыми узлами и не имеют потомков, поэтому их не нужно обрабатывать.
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
      }

     // Один за другим извлекаем элементы из кучи
    for (let i = n - 1; i > 0; i--) {
         // Перемещаем текущий корень в конец
        [arr[0], arr[i]] = [arr[i], arr[0]];
        
        // Вызываем heapify на уменьшенной куче
        heapify(arr, i, 0);
    }
}

const numbers = generateArray(10, 10);
console.log("Initial array:", numbers);

heapSort(numbers);
console.log("Sorted array:", numbers);